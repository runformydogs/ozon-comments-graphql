package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"ozon-comments-graphql/graph/model"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string) (*model.Post, error) {
	p := r.Store.CreatePost(ctx, title, content)

	res := &model.Post{
		ID:               p.ID,
		Title:            p.Title,
		Content:          p.Content,
		CommentsDisabled: p.CommentsDisabled,
		CreatedAt:        p.CreatedAt,
	}

	return res, nil
}

// ToggleComments is the resolver for the toggleComments field.
func (r *mutationResolver) ToggleComments(ctx context.Context, postID string, disabled bool) (*model.Post, error) {
	p, err := r.Store.ToggleComments(ctx, postID, disabled)
	if err != nil {
		return nil, err
	}

	return &model.Post{
		ID:               p.ID,
		Title:            p.Title,
		Content:          p.Content,
		CommentsDisabled: p.CommentsDisabled,
		CreatedAt:        p.CreatedAt,
	}, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, content string) (*model.Comment, error) {
	p, err := r.Store.CreateComment(ctx, postID, parentID, content)
	if err != nil {
		return nil, err
	}

	return &model.Comment{
		ID:        p.ID,
		PostID:    p.PostID,
		ParentID:  p.ParentID,
		Content:   p.Content,
		CreatedAt: p.CreatedAt,
	}, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	posts := r.Store.ListPosts(ctx)
	var res []*model.Post

	for _, post := range posts {
		res = append(res, &model.Post{
			ID:               post.ID,
			Title:            post.Title,
			Content:          post.Content,
			CommentsDisabled: post.CommentsDisabled,
			CreatedAt:        post.CreatedAt,
		})
	}

	return res, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	p, err := r.Store.GetPost(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Post{
		ID:               p.ID,
		Title:            p.Title,
		Content:          p.Content,
		CommentsDisabled: p.CommentsDisabled,
		CreatedAt:        p.CreatedAt,
	}, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, postID string, first *int32, after *string) (*model.CommentPage, error) {
	limit := 10
	if first != nil && *first > 0 {
		limit = int(*first)
	}

	rawComments, next := r.Store.ListComments(ctx, postID, limit, after)

	items := make([]*model.Comment, len(rawComments))
	for i, c := range rawComments {
		items[i] = &model.Comment{
			ID:        c.ID,
			PostID:    c.PostID,
			ParentID:  c.ParentID,
			Content:   c.Content,
			CreatedAt: c.CreatedAt,
		}
	}

	return &model.CommentPage{
		Items:      items,
		NextCursor: next,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
